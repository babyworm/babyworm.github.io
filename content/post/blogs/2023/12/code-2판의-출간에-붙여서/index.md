---
title: CODE 2판의 출간에 붙여서..
author: babyworm
type: post
date: 2023-12-27T17:34:57+00:00
ao_post_optimize:
  - 'a:6:{s:16:"ao_post_optimize";s:2:"on";s:19:"ao_post_js_optimize";s:2:"on";s:20:"ao_post_css_optimize";s:2:"on";s:12:"ao_post_ccss";s:2:"on";s:16:"ao_post_lazyload";s:2:"on";s:15:"ao_post_preload";s:0:"";}'
categories:
  - 개인적인
  - 책이야기
---

원래 이 글은 CODE 2판이 나오기 전이었던 12월 중순에 썼던 글인데, 연말 마무리에 바빠서 다른 것을 하다 이제야 올립니다. 내용이 조금 오래된 부분은 바꾸고, 올립니다.

## Code 2판 번역에 대한 이야기

<figure class="wp-block-image size-large">
  <img decoding="async" src="https://image.yes24.com/goods/124110681/L" alt="" />
</figure>

지난주에 CODE 2판의 마지막 교정본을 보냈습니다. 그리고, 드디어 다음 주면 책이 나옵니다.

  * YES24: <a href="https://www.yes24.com/Product/Goods/124110681" target="_blank" rel="noreferrer noopener">https://www.yes24.com/Product/Goods/124110681</a>
  * 알라딘: <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=330301790&start=slayer" target="_blank" rel="noreferrer noopener">https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=330301790&start=slayer</a>

좋아하는 책을 다양한 측면에서 읽어보고, 해석하는 것이 매우 즐거울 수 있다는 것 때문에 가끔 번역을 합니다.

다만, 언제부터인가 시간이 부족한 나이가 되면서(진실을 이야기하면 예전처럼 빠르게 배우지 못하는 나이가 되면서 새로운 뭔가를 하려면 더 많은 시간을 사용해야 하는 것이겠습니다.), ‘엔지니어의 정성’의 영역에서 해결되는 일들에 대해서 더욱 충분히 시간을 들이지 못하는 것이 아쉬울때가 많습니다.

분명히 한번씩 더 볼때마다 조금씩 조금씩 더 좋아지는 부분이 있는데, 여러번 읽다보니 너무나 자연스럽게 인지의 밖으로 벗어나는 경우들이 있습니다. 더욱이 고쳐지는 부분들이 적어져서 ‘이부분..’이라는 생각에 넘어간 부분이, 나중에 시간을 두고 읽었을 때 또는 다른 편집자/리뷰어 분들에게 너무나도 명확한 오류를 발견하면서 크게 놀랐던 경우도 있습니다. 어느 순간에는 작업을 끝내야 하는데, 결국 효율성과 효과성, 완결성 사이의 어떤 부분에서 끝내게 됩니다.

항상 마지막 교정본을 보낼때마다 ‘실수로 넘어간 부분이 있으면 어떻게 하지’라는 생각이 듭니다.

편하게 읽을 수 있도록 만들고 싶었는데, 그렇다고 내용이 바뀌면 안되니까 다시 추가했다가 점점 더 복잡하게 만들게 되고, 리뷰하다가 지우는 과정을 반복하게 되더군요. 문제는 여러번 우물쭈물하다가 적은 문장은 이도 저도 아니게 오류가 많은 문장이 되어서, 교정 과정에서 편집자님께 많이 죄송했습니다. 교정도 오랜시간동안 진행되었고요.

역자 서문에도 썼지만, 이 책은 저에게 상당히 깊은 의미가 있는 책입니다.

저는 석사때 한동안 다양한 컴퓨터 아키텍처 책을 읽었던 적이 있습니다. 당시에 교보문고에는 ‘교재’용으로 비교적 저렴하게 나온 원서들이 많았고, 학교 도서관에도 다양한 책이 있었는데, 이 서고의 작은 한 부분을 다 읽어보는게 목표라면 목표였던 시절이었습니다. 당시에는 여러 대가들이 같은 부분을 서로 다른 관점과 여러가지 수준으로 설명하는 것이 재미있었습니다. 또한, 책을 읽을수록 더욱 속도가 붙는 것에 한참 재미를 느끼던 시절이기도 했고요.

이때 읽었던 책 중의 하나가 CODE 입니다.

사실 기술 서적이라기에는 너무 글자가 많아서 주저 주저했는데, 당시 일종의 바이블이었던 Programming Windows를 지은 펫졸드님의 책이라는 점에서 손이 가는 걸 어쩔 수 없었습니다. 다만, 당시에는 앞 부분의 내용은 다 아는 내용이네.. 라고 간단하게 생각하면서 대충 대충 읽어가다가 ‘오~’ 했던 기억이 있습니다.

한참 지나서 저를 잘 평가해주셨던 제 첫 회사에서 상용 마이크로 프로세서를 만들고, 관련된 시스템 소프트웨어들을 고쳐가면서 알게 된 것들을 회사의 대외비가 아닐 법한 것들 혹은 개인적인 취미생활(?)에서 알게 된 것을 공유하는 블로그에 이런 저런 글을 쓰고 있던 와중에 이 책에 대한 번역 의뢰가 왔었고, 이 책의 초기 번역판에 대한 문제를 저도 알고 있었기에 영어를 잘하지도 못하면서 어줍지 않게도 ‘이 책은 다른 분들이 조금 많이 읽는 책이 되어야 한다’는 생각을 가지고 작업했습니다. 이 책이 제 첫 번역서가 되었습니다.

가끔 물어보시는 분들께도 이야기하지만, 이 작업은 저에게 ‘해야 할 일’ 혹은 ‘즐거운 일’의 범주에 들 수 있을 때만 진행합니다. 번역을 해본 분은 아시겠지만, 매우 비효율적이거든요. 특히 저처럼 영어를 잘 못하는데다가, 회사 일을 하면서 주말 정도에만 작업을 진행해야 하는 경우에는 말이죠.

그럼에도 이 책은 그럴만한 가치가 있었습니다.

## Code 2판을 읽으시는 요령

아무도 읽지 않으실 역자 서문에도 적었지만, 이 책은 읽기 쉬운 전반부(대략 13장까지)와 잘 안 읽히는 후반부(대략 24장까지), 그리고, 그나마 조금 읽을만한 끝부분(25장부터 28잘까지)으로 이뤄져 있습니다. 사실 저는 후반부 부분이라 할 수 있는 논리 회로를 ‘효율적/효과적’으로 잘 만들어내는 방법을 찾는 사람이라 후반부의 설명이 추가되고, 1판에서 내용이 갑자기 튀는 부분들이 줄어들어서(대신 양이 매우 많이 늘어났죠) 아주 좋았습니다.

이 후반부를 읽으실 때는 최대한 <https://codehiddenlanguage.com/> 에 있는 interactive demo를 참고하세요. 제 생각에 이번 판에서 가장 중요한 contents는 이 홈페이지에 있는 예제들입니다. 스위치들을 조작하면서 어떻게 동작하는지 ‘조금이라도’ 직관적으로 받아들이실 수 있습니다.

그럼에도, 소프트웨어 하시는 분들 혹은 초보자분들에게는 후반부(특히 18장부터 23장까지)가 매우 어려울 수 있겠다고 생각합니다. 서문에 적었듯이 자세한 부분들은 그냥 그러려니 넘어가셔도 됩니다. 나중에 다시 읽어보면서 ‘이게 이렇게 연결되는 것이었다니!’하는 순간이 있을텐데, 처음부터 너무 정신력을 소모하실 필요는 없다고 생각합니다.

중요한 것은 어떤 ‘생각의 흐름’으로 프로세서가 만들어지는 것인지를 보는 것입니다. 실제로 만드실 분이 아니라면 클럭이 어떻게 분주되는지, 각각의 명령어가 어떤 제어 회로의 어떤 신호를 켜주는지, 각 프로세서의 제어 사이클이 어떻게 될지 아는 것이 아주 중요하다고 생각하지는 않습니다. (요즘의 책에서는 여기에 있는 multi-cycle implemtation보다 pipeline implementation을 더 많이 설명하는데, 제 경험으로도 그렇고, 다른 분들의 의견도 이렇게 제어를 설명하는 것이 학생들에게 더 쉽게 받아 들여지는 것 같기도 합니다.)

다만, 메모리에 있는 어떤 값을 읽어와서 ‘명령어로 인식’하는 stored program (혹은 von Neuman architecture라고도 할 수 있는) 개념이나, 읽어온 명령어가 디코더에서 해석되어 제어신호를 만들고, 제어신호가 적절한 산술/논리 회로를 제어하고, 적절한 경로를 제어함으로써 최종적인 결과를 얻어낸다는 점, 그리고, 분기가 어떤 효과가 있는지 정도만 알아도 충분합니다. 즉, 하나 하나 어떤 방식으로 쌓아 올린 것인지 아는 것이 중요하다는 것이죠.

이런 측면에서 컴퓨터, 즉 하드웨어와 소프트웨어를 잘 harmonize시키는 것은 마치 건축물을 하나 하나 쌓아 올리는 것과 비슷하고 할 수 있습니다. 건축물을 볼 때, 전반적인 형태나 구성이 중요하지, 각 블록의 재질이나 특성을 정확하게 이해하는 것은 만들 분들은 꼭 알아야 하는 것이겠으나, 조망하시는 분들은 알면 더 재미있는 부분 정도로 넘어가도 됩니다.

음.. 길어졌는데, 후반부에는 앞의 내용을 기억하지 못하면 따라가기 힘든 detail들이 상당히 있습니다. 회로를 만들어야 하기 때문이죠. 하지만, 이런 부분을 못따라가도 그러려니.. 하면서 지나가셔도 됩니다. 아.. 이렇게 생겨서 이렇게 제어 신호를 넣어주나 보다, 이 부분은 이렇게도 되네.. 정도로 생각하면 매우 좋고, 그것도 힘들면 그냥 뭔가를 만들고(data path라 불리는 연산 혹은 데이터의 경로), 이걸 제어하는 부분(control unit이라 불립니다.)을 만드는 순서로 프로세서가 만들어지는 것이고, 이 제어 부분과 데이터 처리 부분은 클럭에 의해서 제어된다는 정도만 아셔도 되는 것이죠.

따라서, 클럭이 빨라지면 더 많은 연산을 할 수 있고, 범용 머신에서는 ‘속도가 모든 것을 말하는 경우’가 되면서 속도에 따라 응용 분야가 크게 늘어나게 되는 것이죠. 대부분의 실시간 처리라던지, 영상 처리라던지, 인공지능과 같은 대부분의 것이 ‘실질적으로 사용할 수 있는 수준의 성능에 도달하면서 가능해진 것입니다. 즉, 알고리즘은 이전부터 있었으나, 예전에는 ‘속도 문제’로 불가능했던 것이 이제 ‘가능한’ 것이 되는 경우가 허다합니다. (물론, application의 폭발적인 증가로 인해서 ‘전용 하드웨어’가 보조하는 경우도 많죠.)

힘드셨던 후반부를 지나가시면, 이제 읽으실 만한 종반부로 달려가게 되는데, 이 부분에서는 프로세서가 외부 세계와 소통하는 부분, 프로세서에 올라가는 소프트웨어의 발전, 그리고 인터넷의 발전으로 구성됩니다.

인터넷 부분은 기술적인 내용이라기 보다는 저로써는 ‘새로운 시각’이라는 점에서 좋았습니다. 전공이 전공이다보니 OSI 7계층이니, TCP/IP니, 소켓 등을 배우던 사람에게, 예전부터 많은 사람들의 상상이 실제로 실현되는 과정이라는 관점과 이러한 지식의 집대성으로 wikipedia를 지적한 것이 매우 흥미로운 부분이었습니다. 몇 명의 전문가가 만들어내는 시대에서 많은 사람들이 데이터를 공유하고, 수정하면서 더욱 더 좋은 내용이 채워지는 것이죠.

물론, 국내에서는 wikipedia 보다는 나무위키가 더 유명하고, 체계적으로 지식이 정리되어 있죠. (물론, 틀린 부분도 있습니다만, 많은 분들이 참고하실 것으로 생각합니다.), 최근에는 LLM 덕분에 이걸 찾아보는게 아니라 ‘물어보는 것’이 너무나도 자연스러운 시대가 된 것 같습니다. 저만해도 Bard, Bing Chat, ChapGPT에게 묻는 것이 자연스러워졌으니까요. (또 한 15~20년쯤 후에 이 부분이 너무 자연스러워진 시점에서 3판이 나오지 않을까요?)

CODE에 있는 논문의 예로 들은 JSTOR의 경우(저는 보통 IEEExplorer나 AMC digital library를 주로 참고하는지라, JSTOR에 갈 일이 별로 없기는 한데요.) 사건이 많아서 각주가 길어져서 일부분만 남겨두었는데, 최근에는 Open Access 전용 저널들이 나오면서 어느 정도 빗장이 풀리는 추세입니다. 제가 장문의 역자주를 썼지만, 책에 들어가기에는 너무 많아서 줄여서 들어갔는데..여기에 적자면.. (너무 길기는 하네요. 사실 저 사건을 읽었을 때 약간 분노(?)하기도 했고, 최근까지 여러개의 Digital Library를 구독하면서 매우 폐쇄적인 정책에 고생하기도 해서 너무 글이 길어진 것이죠. )

<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">

    JSTOR의 경우 저널/논문에 대한 접근 권한을 기업이나 기관에 판매하는 모델을 가지고 있었는데, RSS를 만든 애런 스워츠가 과도한 양의 저널 논문을 다운받은 사실을 확인하고 고소를 진행했으며, 이로 인해서 애런 스워츠가 자살하면서 강력한 비판을 받은 사건입니다. https://www.harvardmagazine.com/2013/01/rss-creator-aaron-swartz-dead-at-26<br>이 사건 이후에 JSTOR은 몇개의 논문은 무료로 받을 수 있도록 정책을 변경했습니다.<br>여기는 나와있지 않으나 과연 많은 연구자들의 노력으로 만들어지고, 공적인 자금이 투입된 논문을 사유화해서 판매하는 것이 옳은지(게다가 원저자에게 따로 수익을 분배하고 있지도 않고, 심지어 논문 게재비를 받고 있으니까요)에 대한 비판이 매우 강하며, 최근에는 Open Access라는 이름으로 다양한 학회에서 무료 논문지 혹은 저자의 동의에 의해서 일부 논문을 공개하는 모델을 만드는 추세가 확대되고 있습니다.<br>극단적인 예이기도 하지만, 유료 논문들을 모아서 Open Access로 공개해버린 sci-hub 역시 논문을 사유화하고 있는 출판사에 대한 비판에서 출발한 프로젝트라 할 수 있습니다.

</blockquote>

## 마치며

제 생각에 이 책은 ‘자세히’ 다 읽기 쉽지 않은 책입니다. 저처럼 ‘하드웨어’와 ‘소프트웨어’ 중간 혹은 하드웨어에 중심을 두고 소프트웨어를 바라보시는 분들, 임베디드 소프트웨어/시스템 소프트웨어를 하면서 약간 하드웨어 쪽을 더 알고 싶으셨던 분은 후루룩(혹은 약간 ‘끙~’하면서) 읽어보실 수 있을 것이지만, 소프트웨어 쪽에서 바라보기엔 조금 어려운 부분들이 분명히 있습니다.

다만, 후반부의 많은 부분은 ‘디테일’까지 알지 못하더라도 대략의 흐름만 잡으면서(극단적으로는 약간씩 스킵을하시더라도) 끝까지 도달해 보시길 바랍니다.

여러분을 조금이라도 도와드리기 위해서, 후반부가 어려운 분들을 위해서 제가 추천하는 ‘읽어야 할 부분’입니다.

  * 14장: 논리 게이트 종류와 논리 연산에 대해서 이해하고, 이진수 덧셈을 논리 게이트로 바꿔보는 것
  * 15장: 요 장은 읽기 편하실 것 같습니다. 이야기 읽듯 읽으시면 됩니다.
  * 16장: 이진수 뺄셈이 보수를 이용한 덧셈이라는 점을 이해하세요. 회로는 중요하지 않습니다.
  * 17장: 피드백이라는 것이 어떤 것인지, 플립플롭이 어떻게 데이터를 저장하는지 개념만 아시면 됩니다. 모두 피드백을 통해서 데이터를 가두는 것이죠.
  * 18장: 클럭이란 것을 어떻게 만들고, 분주하는지, 실제로는 카운터 같은 것이라는 점을 이해하시면 됩니다. 실제 BCD 시계를 만드는 과정을 보실텐데, 대략 논리적으로 ‘이런 논리’를 만들어서 회로로 만든다는 예를 보여주는 것입니다. 회로가 중요하지는 않지만, 궁금하신 분들도 있을 것 같습니다.
  * 19장: 앞에서 본 플립플롭을 어레이로 배치해서 메모리를 만들 볼 겁니다. 실제 여러분이 아시는 DRAM은 이렇게 만들어지지는 않지만, 대충 ‘주소’란 것이 어떤 것인지에 대해서 이해하시면 됩니다.
  * 20장: 자.. 이제 프로세서입니다. 연산을 자동화 시키는 것이 어떻게 가능한지만 따라가 봅시다. 메모리에 있는 값을 ‘제어신호’로 바꾸는 부분이 핵심입니다. 제어 명령 하나를 읽어서 더하는 ‘데이터 패스’를 조정하는 겁니다.
  * 21장: 데이터패스를 추가하는 겁니다. 더 복잡해졌으니, 더 복잡한 제어가 필요하겠죠? 대충 넘어가셔도 됩니다. 연산의 결과를 이용해서 ‘플래그’라는 것을 만드는 것은 나중에 조건 분기에서 사용됩니다.
  * 22장: 메모리만 사용하는 것이 아니라, 내부 레지스터와 버스를 사용하는 방법을 알려줍니다. 즉, 데이터 패스 구성요소를 설명하는 것입니다. x86을 조금 깊게 읽어보신 분들은 Ax, Bx, Cx, Dx라는 전통적인 레지스터들을 아실텐데, 여기에 대한 내용입니다. 이 부분을 이해하시면 나중에 x86 어셈블리 읽을 때 도움됩니다. 읽으실 일이 없다면, 대충 이런게 있군.. 하고 넘어가셔도 됩니다.
  * 23장: 제어 유닛 부분입니다. 아마도 가장 읽기 어려우실 수 있겠습니다. 회로는 중요하지 않으며, 데이터 패스를 ‘각각의 실행 사이클’에서 어떤 방식으로 제어해서 해당 동작을 만들어내는지 이해하면 좋습니다.
  * 24장: 분기에 대해서 다룹니다. 연산된 결과를 통해서 만들어지는 플래그를 통해서 ‘조건’ 분기가 이루어지며, 함수 호출은 돌아올 곳을 저장하는 일종의 특수한 형태의 ‘분기’라는 점만 이해하셔도 됩니다.

구체적인 예를 따라가 보시면 더 즐길 수 있으시겠지만, 재미가 떨어지는 수준까지 고민하실 정도는 아닙니다. 위의 내용(개념)만 잡으면서 지나가시고, 언젠가 필요할 때 지나가셨던 부분을 한번 더 읽으시는 게, 이 책을 읽을 때 더 좋은 방식이라 생각합니다.

모두 즐겁게 즐기시길 바랍니다.
