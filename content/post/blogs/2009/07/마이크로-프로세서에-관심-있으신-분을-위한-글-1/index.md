---
title: 마이크로 프로세서에 관심 있으신 분을 위한 글.
author: babyworm
type: post
date: 2009-07-23T06:38:11+00:00
bfa_virtual_template:
  - hierarchy
categories:
  - Microprocessor
tags:
  - 마이크로 프로세서

---
> 이 글은 예전에 쓴 &#8220;<a href="https://babyworm.github.io/post/blogs/2006/09/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C/%EB%B9%84%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B0%98%EB%8F%84%EC%B2%B4-%EC%84%A4%EA%B3%84%EB%A5%BC-%ED%9D%AC%EB%A7%9D%ED%95%98%EC%8B%9C%EB%8A%94-%EB%B6%84%EB%93%A4%EA%BB%98../" target="_blank">프로세서/비메모리 반도체 설계를 희망하시는 분들께</a>&#8220;라는 글과 연관성이 있습니다. 단지 프로세서 설계를 희망하시는 분들께 유용할 수도(?) 있는 내용 위주로 쓰여졌다는 것만 다르겠습니다.



일단 마이크로 프로세서라는 분야에 대해서 설명이 필요할 것으로 봅니다. 학교에서 마이크로 프로세서 구현에 대한 연구는 EE(전자공학)에서 이루어지는 것이 대부분이며, 기업체의 경우 embedded microprocessor는 상당히 많은 업체에서 상용화에 도전하고 있습니다.

하지만, 마이크로 프로세서라는 분야는 그 특성상 몇몇 ISA(명령어 셋 아키텍쳐) 들이 그 점유율을 크게 가져가는 경우가 많기 때문에, 독자적인 ISA를 지닌 마이크로 프로세서를 만들어서 성공한다는 것은 매우 어렵습니다. 이는 사용할 수 있는 프로그램의 수가 많고, 개발자 pool이 튼튼한 프로세서가 계속하여 성장한다는 당연한 이야기(eco-system이라고 보통 표현되는..) 때문입니다.

일례로 PC/서버 계통에서는 x86 ISA가 완전하게 시장을 장악했다고 해도 과언이 아니며, 그 이외의 ISA가 들어오기는 매우 어려울 것으로 봅니다. (그런 측면에서 저는 ARM이 PC 마켓 &#8211; netbook이라 불리는 부분에 있어서도..-에서 점유율을 가져 오기는 매우 어려울 것으로 생각하고 있습니다.)

국내에서는 자체 ISA를 가진 프로세서를 설계하는 회사도 거의 없을 뿐 아니라, 이를 지원해 줄 수 있는 컴파일러와 OS를 만드는 회사도 거의 없습니다. 여러가지 여건 상 마이크로 프로세서를 하시는 분들께는 좋지 않은 여건이지요

그럼에도 기업체에서는 학교에서 마이크로 프로세서를 선택하신 분들에 대한 요구가 적지 않은 데요.. 그 이유는 마이크로 프로세서를 만들기 위함이라기보다, 마이크로 프로세서를 이루고 있는 여러 가지 기술을 기반으로 다른 기술에 적응이 빠르다는 장점 때문입니다. 마이크로 프로세서를 만드시는 분들은 소프트웨어와 하드웨어, 모델링 등에 어느 정도 넓은 지식을 갖추어야 하며, 하드웨어에 있어서도 연산기, 제어 유닛, 버스, 캐시 등에도 어느 정도 이상의 지식을 갖추어야 하는데 이런 폭넓은 지식들이 다양한 설계를 하는데 좋은 밑바탕이 되기 때문입니다.

특히 마이크로 프로세서를 공부한다는 건 제어와 연산, 메모리 접근을 최적화 시키는 데 있어서 상당히 깊은 지식을 얻게 되는데, 이러한 지식은 여러 종류의 프로세서 – video, multimedia, audio, network processor등-에 아주 유용하게 사용할 수 있는 기반을 갖추게 된다는 걸 의미합니다.

대충 마이크로 프로세서를 공부한다는 것이 어떤 의미인지는 설명 드렸으니, 그럼 프로세서를 하려면 뭐를 봐야 하느냐 하는 문제에 대해서 설명하겠습니다.

프로세서를 만드는 건 1) 상위 레벨 모델을 기반으로 작업하는 것, 2) RTL 수준까지의 설계, 3) gate 수준에서의 설계 정도로 나누어 생각해 볼 수 있겠습니다. 세 가지 모두 어느 정도 갖추어야 하겠습니다만, 학교에서 논문을 쓰기 위해서는 1)번을 잘해야 하고, 칩을 보고 싶으면 2)번을 잘해야 하고, 우리나라 회사에서 적응하기 쉬우시려면 3)번도 잘해야 합니다.

일단, 프로세서에는 다양한 스펙트럼이 존재합니다. 일례로 프로세서의 구조, 분기 예측, pipeline의 형태, 새로운 연산기나 명령어 적용, 값의 예측 등에 따른 performance변화나 전력 소모의 변화를 연구하게 되는데, 이런 것을 할 때 마다 실제 칩을 설계를 하게 되면 졸업할 수 있는 분이 없으실 테니 일반적으로 C 수준의 simulator를 이용하게 됩니다.

이러한 연구에 들어가기 위해서는 앞에서 이야기 된 S/W가 어떻게 컴파일 되어서 프로세서에게 인식되는지에 대한 이해(ISA)와 더불어 프로세서를 구성하는 여러 가지 요소 – pipeline, cache, virtual memory –에 대한 이해가 있어야지 연구가 진행될 수 있겠습니다. 생각보다 기본적인 데이터 통신이나 데이터 구조에 대한 이해는 아이디어를 얻어내는데 아주 많은 도움을 줍니다. 또한, 많은 경우에 수학적 모델을 세워야 할 필요가 있으므로, 수학적 모델에 대해서도 알아두실 필요가 있습니다.전력 측정 등을 하게 되면 당연히 기본적인 전자회로에 대한 이해는 필수적일테구요

이러한 상위 수준의 모델을 이용한 연구에 가장 널리 사용되는 것은 simplescalar라는 시뮬레이터지요. 이 시뮬레이터는 alpha 아키텍쳐에 기반을 두고 처음에 만들어졌는데 구조가 유연해서 ARM 버전도 있고, (EISC 버전도 있고..) 전력 측정을 위한 simplepower라던지 여러 variation들이 있습니다. 여러분들이 연구를 진행할 때도 마찬가지로 해당 시뮬레이터에 자기의 아이디어를 적용시켜 modify하고 성능을 보는 형태로 연구를 진행하고, 논문을 쓰는 거죠. 이런 일을 위해서는 기본적으로 &#8220;**C/C++ 와 기본적인 데이터 구조 및 알고리즘에 대해서는 어느 정도 이상 할 줄 알아야 합니다.**&#8221; 몇 번 말씀 드렸습니다만, 이쪽 분야 엔지니어에게 있어서 C/C++은 그냥 언어나 다름 없습니다.

두 번째로 자신의 idea가 어느 정도 확정되었으면, 이것을 RTL(register transfer level)로 설계(보통 verilogHDL이나 VHDL을 사용합니다.)해서, 논리 합성이라는 과정을 거쳐야 합니다. 이때 아이디어가 좋았고, 아키텍쳐가 좋았어도 논리 회로에 대한 기본적인 이해가 없다면 좋은 회로를 만들어내기 어렵습니다. 따라서, &#8220;**논리 회로에 대한 이해**&#8220;와 &#8220;**RTL 설계를 위한 언어 &#8211; verilog든 VHDL이던**&#8220;는 기본적으로 필요합니다.

세 번째로 gate 수준의 설계는 국내 대기업에서 프로세서 작업을 할 때 많이 사용되는데요..(gate 수준의 최적화를 많이 하시니..) 저는 이 분야에 교양적인 지식 밖에 없어서 조언을 드릴 부분이 매우 작습니다. <span style="font-family: Wingdings;">J</span>

아.. 책 이야기를 빼 놓았군요.

저는 Architecture에 있어서는 처음 시작하신다면 Hennessy & Patterson의 computer organization & design이라는 책이나 M.Mano의 책으로 시작하시는 것이 무난하다고 봅니다. 이후에 Hennessy & Patterson의 책(CAQA라 불리는)과 Flynn의 책을 추천해 드리고 싶습니다. 쉽게 읽힐 분량도 아니고, 쉽게 읽히는 내용도 아닙니다만 꼭 한번은 완독 하시길 바랍니다. 깊이 있게 보다는 넓게 보시고 싶으시다면 Sima의 책(advanced computer architecture)도 추천해 드릴만 합니다.

설계의 교양이라는 점에 있어서는 ASIC이라는 책을 보시고 난 이후에 Chinnery의 Closing the Gap Between ASIC and Custom이라는 책도 괜찮습니다. 상당히 괜찮은 관점을 보여줍니다.

RTL Design에 있어서는 (VerilogHDL이나 VHDL과 같은 HDL을 아신다는 가정하에 – verilog에 관련된 책은 예전에 제가 추천한 적이 있습니다. ) Reuse Methodology Manual을 &#8220;반드시&#8221; 읽어보시길 권하고 싶습니다. 학교에서 짜여진 코드가 생각보다 구닥다리 코딩 스타일을 가지고 있는 경우가 많습니다. Software engineering과 마찬가지로 하드웨어에서도 요즘 중요한 문제는 HDL코드의 readability와 reusability 입니다. 아주 critical 한 부분이 아니라면 약간 타이밍과 면적에 손해를 보더라도 요즘 코딩 스타일을 따르시는 것이 지속적으로 코드를 갱신 할 수 있습니다.

Verification에 있어서는 Comprehensive functional verification이라는 책을 권해 드리고 싶습니다. SoC 시리즈 입문서이기도 하고 잘 쓰여진 책입니다.

마지막으로 마이크로 프로세서를 만드시려는 분들께 한가지만 더..

마이크로 프로세서를 만들 때 가장 중요한 것이며, 가장 간과하기 쉬운 것이 ISA 입니다. 사실 ISA의 설계가 마이크로 프로세서에 있어서 절반 이상이라고 봅니다. 마이크로 프로세서에 있어서 ISA는 이 프로세서가 지향하고 있는 점(철학이라고 하면 좀 거창하고&#8230;)을 가장 잘 표현합니다. 학교에 계신 많은 분들은 &#8220;어떻게 하면 쉽게 프로세서가 설계 될 것인가?&#8221;라는 관점에서 ISA를 설계하시는 경우도 많지요 ^^; 또한, 어떤 프로세서의 경우는 표면적으로 지향하는 바와 ISA가 전혀 매칭이 안되는 경우도 있구요.

EISC의 경우는 ISA를 설계할 때 다양한 실험을 통해서 &#8220;프로그램의 크기와 메모리 접근이 가장 줄어들도록 하려면 어떻게 해야 하는가?&#8221; 라는 관점에서 모든 명령어 셋이 설계 되었습니다. 이는 임베디드에서는 프로그램의 크기 = cost라는 공식이 성립하기 때문이기도 하고, processor와 memory간의 속도 차가 점점 벌어질 것이라는 관점, memory접근으로 인하여 발생하는 전력 소모의 문제 등을 고려하여 잡은 목표입니다(EISC의 요즘 마케팅 포인트 중의 하나가 energy efficient microprocessor 이지요). 이를 위하여 다양한 실험이 수행되었고, 이중에 가장 적합하다고 생각하는 명령어 형태가 결정된 것이지요. 한 비트 한 비트 설계가 쉽게 이루어진 것은 아니고, 모두 의미가 있지요. 이후에 추가된 DSP 확장 명령어들도 각기 다양한 DSP 커널을 분석하고 이를 기반으로 ISA가 정해졌고, 구현할 때도 이런 부분이 고려되었습니다. 이런 목표 하에 설계되어 명령어의 형태가 일반적인 compressed code RISC들 보다는 약간 더 복잡하고, 이는 디코더 복잡도를 높이는 단점으로 바뀝니다. 달리 이야기하면, ISA를 설계할 때 어떤 결정은 어떤 면에서는 장점이 되지만, 다른 측면에서는 단점이 되는 부분이 있으니 조심해서 결정해야 할 부분이 많은 거죠.

마이크로 프로세서를 공부하고자 하시는 분들께 마지막으로 말씀 드리자면, 최소한 1년 정도는 넓게 공부하시고, 되도록 책을 많이 읽으시라는 &#8220;아주 지극히 일반적인&#8221; 말씀만을 드릴 수밖에 없네요. ^^; 또 한가지는 프로세서를 하실 분들은 DSP, 데이터 통신에 대해서는 어느 정도 알고 계신 것이 여러모로 도움이 됩니다.

결론 없는 &#8220;공부하세요&#8221;라는 글이 되었군요. 아.. 요즘 나 왜 이래.. orz
